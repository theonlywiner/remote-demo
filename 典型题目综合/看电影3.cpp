//虎哥看电影 III
//时间限制 3 秒
//空间限制 128 MB
//虎哥去影城看电影，每部电影有开始时间、结束时间和好看度等信息。由于看完一部电影后需要换影厅，
//因此下部电影的开始时间必须严格大于上部电影的结束时间才能观看。
//
//但是虎哥现在没有钱了，也就是说他不能无限场次看电影。请帮他选择看哪些电影，
//使所选电影的好看度之和最大。
//
//输入
//第一行包含 2 个整数 n 和 k，表示有 n 场电影，并且虎哥最多只能买 k 张电影票。
//
//接下来 n 行，表示每一场的电影信息，即开始时间 s、结束时间 t 和好看度 v。
//
//输出
//输出虎哥在看电影数不超过 k 的情况下，好看度最大之和。
//示例
//示例 1
//输入
//
//3 2
//1 2 4
//3 4 3
//2 3 1
//输出
//
//7
//示例 2
//输入
//
//3 2
//1 2 4
//3 4 3
//2 3 10
//输出
//
//10
//示例 3
//输入
//
//4 3
//1 1 1
//2 2 2
//3 3 3
//4 4 4
//输出
//
//9
//主要思路：动态规划和二分查找
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,k;
    cin >> n >> k;
    vector< vector<int> >a(n,vector<int>(3));//使用vector制造二维数组
    for (int i=0;i<n;i++){
        cin >> a[i][0] >> a[i][1] >> a[i][2];
    }
    sort(a.begin(),a.end(), [](auto &a,auto &b){return a[1]<b[1];});//对结束时间排序
    int f[n+1][k+1];		//f[i][j]表示前i个电影，最多选k个电影最大的满意度之和
    memset(f,0,sizeof(f));	//memset对f数组全部定为0
    for (int i=0;i<n;i++){
    	//p是对于a[i]开始时间最接近的前面的电影的结束时间，即最大满意度的可能
        int p=lower_bound(a.begin(),a.begin()+i,a[i][0],[](auto &e, int lower) { return e[1] < lower; })-a.begin();
        for (int j=1;j<=k;j++){
            f[i+1][j]=max(f[i][j],f[p][j-1]+a[i][2]);//表示不看这个i与看这个i哪个大存放
        }
    }
    cout << f[n][k];
    return 0;
}